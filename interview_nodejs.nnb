{
    "cells": [
        {
            "language": "markdown",
            "source": [
                "# Node.js Interview Questions\n\nThis notebook contains 20 interview questions about Node.js and related packages, with explanations and sample code where applicable."
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "## Question 1: What is Node.js and what are its key features?\n\n**Answer:**\nNode.js is an open-source, cross-platform JavaScript runtime environment that executes JavaScript code outside a web browser.\n\n**Key features include:**\n- Event-driven, non-blocking I/O model\n- Single-threaded event loop\n- Asynchronous by nature\n- NPM (Node Package Manager)\n- Cross-platform compatibility\n- High performance for real-time applications"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "## Question 2: Explain the concept of the Event Loop in Node.js.\n\n**Answer:**\nThe Event Loop is a mechanism that allows Node.js to perform non-blocking I/O operations despite JavaScript being single-threaded.\n\nIt works by:\n1. Putting operations into the event queue\n2. Processing them when the call stack is empty\n3. Executing callbacks when async operations complete\n\nBelow is an example of the event loop in action:"
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "console.log(\"First\");\nsetTimeout(() => {\n  console.log(\"Third - from timeout\");\n}, 0);\nconsole.log(\"Second\");\n// Output: First, Second, Third - from timeout"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "## Question 3: What is the difference between Node.js and traditional web server software like Apache?\n\n**Answer:**\nApache is a traditional thread-based server where each request creates a new thread, consuming system resources.\nNode.js uses a single-threaded event loop model with non-blocking I/O, making it more lightweight and efficient for handling many concurrent connections.\n\n**Key differences:**\n- Apache is better for CPU-intensive operations\n- Node.js excels at I/O-bound applications\n- Apache uses multiple threads to handle requests\n- Node.js handles many connections on a single thread"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "## Question 4: Explain how you would create a simple HTTP server in Node.js.\n\n**Answer:**\nNode.js has a built-in 'http' module to create HTTP servers. Below is an example:"
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "const http = require(\"http\");\n\nconst server = http.createServer((req, res) => {\n  res.statusCode = 200;\n  res.setHeader(\"Content-Type\", \"text/plain\");\n  res.end(\"Hello World\\n\");\n});\n\n// To start the server:\n// server.listen(3000, '127.0.0.1', () => {\n//   console.log('Server running at http://127.0.0.1:3000/');\n// });"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "## Question 5: What is Express.js and why is it popular?\n\n**Answer:**\nExpress.js is a minimal and flexible Node.js web application framework that provides a robust set of features for web and mobile applications.\n\n**It's popular because:**\n- It simplifies routing\n- Provides middleware support\n- Integrates easily with many template engines\n- Has a large ecosystem of plugins\n- Makes error handling straightforward\n\nBelow is an example of a basic Express app:"
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "// const express = require('express');\n// const app = express();\n//\n// app.get('/', (req, res) => {\n//   res.send('Hello World!');\n// });\n//\n// app.listen(3000, () => {\n//   console.log('Express app listening on port 3000');\n// });"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "## Question 6: How does Node.js handle asynchronous operations?\n\n**Answer:**\nNode.js handles asynchronous operations through:\n1. Callbacks - Traditional approach\n2. Promises - Better for handling async flow\n3. Async/await - Modern, more readable approach\n\nExamples of each approach:"
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "// Callback example\nconst fs = require('fs');\nfs.readFile(\"file.txt\", (err, data) => {\n  if (err) throw err;\n  console.log(data);\n});\n\n// Promise example\nconst readFilePromise = (filename) => {\n  return new Promise((resolve, reject) => {\n    fs.readFile(filename, (err, data) => {\n      if (err) reject(err);\n      else resolve(data);\n    });\n  });\n};\n\n// Async/await example\nasync function readFileAsync() {\n  try {\n    const data = await readFilePromise(\"file.txt\");\n    console.log(data);\n  } catch (error) {\n    console.error(error);\n  }\n}"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "## Question 7: What is npm? How is it used in Node.js development?\n\n**Answer:**\nnpm (Node Package Manager) is the default package manager for Node.js. It consists of:\n- A command-line client (npm)\n- An online database of packages (npm registry)\n\n**It's used to:**\n- Install packages (npm install package-name)\n- Manage dependencies in package.json\n- Run scripts defined in package.json\n- Publish and share code with the community"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "## Question 8: Explain the concept of middleware in Express.js.\n\n**Answer:**\nMiddleware functions are functions that have access to the request (req), response (res) objects, and the next middleware function in the application's request-response cycle.\n\n**They can:**\n- Execute any code\n- Make changes to the request and response objects\n- End the request-response cycle\n- Call the next middleware in the stack\n\nExample of middleware in Express:"
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "// const express = require('express');\n// const app = express();\n//\n// // Logger middleware\n// app.use((req, res, next) => {\n//   console.log(`${new Date().toISOString()}: ${req.method} ${req.url}`);\n//   next(); // Pass control to the next middleware\n// });\n//\n// // Route handler\n// app.get('/', (req, res) => {\n//   res.send('Hello World');\n// });"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "## Question 9: How do you handle errors in Node.js applications?\n\n**Answer:**\nError handling in Node.js can be done through:\n1. Try-catch blocks (for synchronous code)\n2. Error-first callbacks (traditional Node.js pattern)\n3. Promise rejections (.catch() method)\n4. Global error handlers (process.on('uncaughtException'))\n5. Express error middleware\n\nExamples:"
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "// Try-catch\ntry {\n  // synchronous code that might throw\n  const result = riskyOperation();\n} catch (error) {\n  console.error(\"Error caught:\", error);\n}\n\n// Error-first callback\nfs.readFile(\"file.txt\", (err, data) => {\n  if (err) {\n    console.error(\"Error reading file:\", err);\n    return;\n  }\n  // Process data\n});\n\n// Global error handler (use with caution)\nprocess.on(\"uncaughtException\", (err) => {\n  console.error(\"Uncaught exception:\", err);\n  // Perform cleanup operations\n  process.exit(1); // Exit with failure code\n});"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "## Question 10: What is the purpose of the package.json file in a Node.js project?\n\n**Answer:**\nThe package.json file serves as a manifest for your Node.js project. It:\n- Contains metadata about the project (name, version, description)\n- Lists dependencies and devDependencies\n- Defines scripts for various tasks (start, test, build)\n- Specifies entry points, engines, license, etc.\n- Can define configuration for various tools\n\nExample package.json:"
            ],
            "outputs": []
        },
        {
            "language": "json",
            "source": [
                "{\n  \"name\": \"my-node-app\",\n  \"version\": \"1.0.0\",\n  \"description\": \"A sample Node.js application\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"start\": \"node index.js\",\n    \"dev\": \"nodemon index.js\",\n    \"test\": \"jest\"\n  },\n  \"dependencies\": {\n    \"express\": \"^4.17.1\",\n    \"mongoose\": \"^5.12.3\"\n  },\n  \"devDependencies\": {\n    \"nodemon\": \"^2.0.7\",\n    \"jest\": \"^26.6.3\"\n  },\n  \"engines\": {\n    \"node\": \">=12.0.0\"\n  },\n  \"license\": \"MIT\"\n}"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "## Question 11: How can you make Node.js applications more secure?\n\n**Answer:**\nTo enhance Node.js application security:\n1. Keep dependencies updated (npm audit, npm update)\n2. Use security headers (Helmet.js in Express)\n3. Implement proper authentication and authorization\n4. Validate and sanitize user inputs\n5. Use HTTPS\n6. Implement rate limiting\n7. Set appropriate CORS policies\n8. Avoid using eval() and other unsafe functions\n9. Handle errors properly without exposing sensitive information\n10. Use environment variables for secrets"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "## Question 12: What are Streams in Node.js and why are they important?\n\n**Answer:**\nStreams are collections of data that might not be available all at once. They are used to handle reading/writing files, network communications, or any kind of end-to-end information exchange efficiently.\n\n**Types:**\n- Readable\n- Writable\n- Duplex\n- Transform\n\n**Advantages:**\n- Memory efficiency (process data in chunks)\n- Time efficiency (start processing without waiting for full data)\n- Composability (pipe streams together)\n\nExample:"
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "const fs = require(\"fs\");\n\n// Reading a large file with streams\nconst readStream = fs.createReadStream(\"large-file.txt\");\nconst writeStream = fs.createWriteStream(\"output.txt\");\n\nreadStream.pipe(writeStream);\n\nreadStream.on(\"data\", (chunk) => {\n  console.log(`Received ${chunk.length} bytes of data`);\n});\n\nreadStream.on(\"end\", () => {\n  console.log(\"Finished reading file\");\n});"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "## Question 13: Explain the difference between process.nextTick() and setImmediate().\n\n**Answer:**\nBoth methods defer the execution of a function but have different priorities:\n\n- **process.nextTick()**: Callbacks queued with nextTick execute immediately after the current operation, before any I/O or timers fire. It has higher priority than setImmediate.\n\n- **setImmediate()**: Callbacks queued with setImmediate execute in the next iteration of the event loop, after I/O callbacks that are already in the event queue.\n\nExample:"
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "console.log(\"Start\");\n\nsetTimeout(() => {\n  console.log(\"setTimeout\");\n}, 0);\n\nsetImmediate(() => {\n  console.log(\"setImmediate\");\n});\n\nprocess.nextTick(() => {\n  console.log(\"nextTick\");\n});\n\nconsole.log(\"End\");\n// Typical output: Start, End, nextTick, setTimeout/setImmediate (order of setTimeout and setImmediate may vary)"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "## Question 14: How do you debug a Node.js application?\n\n**Answer:**\nNode.js applications can be debugged using several methods:\n\n1. Using console.log() statements\n2. Built-in Node.js debugger (node inspect)\n3. Chrome DevTools (--inspect flag)\n4. VS Code's integrated debugger\n5. Third-party tools (ndb, node-inspector)\n6. Logging libraries (winston, pino)\n7. Performance monitoring tools (clinic.js)\n\nExample of using the built-in debugger:\n```bash\n$ node inspect app.js\n```"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "## Question 15: What is the purpose of the Buffer class in Node.js?\n\n**Answer:**\nThe Buffer class in Node.js is used to handle binary data. It was introduced before JavaScript had native support for binary data. Buffers are similar to arrays of integers but correspond to raw memory allocations outside the V8 heap.\n\n**Use cases:**\n- File operations\n- Network operations\n- Cryptography\n- Image processing\n\nExample:"
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "// Creating buffers\nconst buf1 = Buffer.alloc(10); // Creates a buffer of 10 bytes filled with zeros\nconst buf2 = Buffer.from(\"Hello, world!\"); // Creates a buffer from a string\nconst buf3 = Buffer.from([1, 2, 3, 4]); // Creates a buffer from an array\n\n// Converting buffer to string\nconsole.log(buf2.toString()); // 'Hello, world!'\n\n// Working with buffers\nbuf1.write(\"Hello\");\nconsole.log(buf1.toString()); // 'Hello\\u0000\\u0000\\u0000\\u0000\\u0000'"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "## Question 16: What is clustering in Node.js and why would you use it?\n\n**Answer:**\nClustering in Node.js allows you to create child processes (workers) that run simultaneously and share the same server port. Each worker runs on a single thread.\n\n**Benefits:**\n- Improved performance on multi-core systems\n- Better application stability (if one worker crashes, others continue)\n- Easier scaling across CPU cores\n\nExample:"
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "const cluster = require(\"cluster\");\nconst http = require(\"http\");\nconst numCPUs = require(\"os\").cpus().length;\n\nif (cluster.isMaster) {\n  console.log(`Master ${process.pid} is running`);\n\n  // Fork workers\n  for (let i = 0; i < numCPUs; i++) {\n    cluster.fork();\n  }\n\n  cluster.on(\"exit\", (worker, code, signal) => {\n    console.log(`Worker ${worker.process.pid} died`);\n    // Optionally restart the worker\n    cluster.fork();\n  });\n} else {\n  // Workers can share any TCP connection\n  http\n    .createServer((req, res) => {\n      res.writeHead(200);\n      res.end(\"Hello from worker\\n\");\n    })\n    .listen(8000);\n\n  console.log(`Worker ${process.pid} started`);\n}"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "## Question 17: What is the purpose of the module.exports and exports objects?\n\n**Answer:**\nIn Node.js, module.exports and exports are used to expose functions, objects, or values from one module so they can be used in another module.\n\n- **module.exports** is the actual object that's returned by require()\n- **exports** is a reference to module.exports initially\n\n**Important:** If you assign directly to exports, you break the reference to module.exports\n\nExample:"
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "// In math.js\nexports.add = (a, b) => a + b; // Works fine\nexports.subtract = (a, b) => a - b; // Works fine\n\n// This works - assigning properties to exports\nexports.multiply = (a, b) => a * b;\n\n// This won't work - breaking the reference to module.exports\n// exports = {\n//   add: (a, b) => a + b,\n//   subtract: (a, b) => a - b\n// };\n\n// This works - directly assigning to module.exports\nmodule.exports = {\n  add: (a, b) => a + b,\n  subtract: (a, b) => a - b,\n  divide: (a, b) => a / b,\n};\n\n// In another file\n// const math = require('./math');\n// console.log(math.add(2, 3)); // 5"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "## Question 18: How does the 'require' function work in Node.js?\n\n**Answer:**\nThe require function in Node.js is used to import modules. When require() is called:\n\n1. It resolves the path to the module\n2. Checks if the module is already in the cache\n3. If not in cache, loads the module:\n   - Reads and parses the file\n   - Wraps the code in a function\n   - Executes the code\n   - Caches the module\n4. Returns module.exports from the module\n\nThe module resolution algorithm searches in:\n- Core modules\n- node_modules directory\n- Directories specified in NODE_PATH"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "## Question 19: What is the Event Emitter pattern in Node.js?\n\n**Answer:**\nThe EventEmitter is a core module in Node.js that facilitates communication between objects. It uses the Observer pattern where objects can subscribe to events and get notified when those events occur.\n\nExample:"
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "const EventEmitter = require(\"events\");\n\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\n\n// Register an event listener\nmyEmitter.on(\"event\", (arg1, arg2) => {\n  console.log(\"Event triggered!\", arg1, arg2);\n});\n\n// Trigger the event\nmyEmitter.emit(\"event\", \"arg1\", \"arg2\");"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "## Question 20: What are some common design patterns used in Node.js applications?\n\n**Answer:**\nCommon design patterns in Node.js include:\n\n1. Module pattern - Encapsulating code in modules\n2. Singleton pattern - Single instance, often used for database connections\n3. Factory pattern - Create objects without specifying exact class\n4. Observer pattern - Through Event Emitters\n5. Middleware pattern - Used extensively in Express.js\n6. MVC (Model-View-Controller) - Separation of concerns\n7. Repository pattern - Abstraction layer between business logic and data\n8. Dependency Injection - Passing dependencies instead of hardcoding them\n\nExample of Singleton pattern:"
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "// database.js\nclass Database {\n  constructor() {\n    if (Database.instance) {\n      return Database.instance;\n    }\n\n    this.connection = null;\n    this.connect();\n    Database.instance = this;\n  }\n\n  connect() {\n    // Establish database connection\n    this.connection = \"Connected to DB\";\n  }\n\n  query(sql) {\n    return `Executing query: ${sql}`;\n  }\n}\n\nmodule.exports = new Database();\n\n// Usage in other files:\n// const db = require('./database');\n// console.log(db.query('SELECT * FROM users'));"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "## Question 21: How do you connect to different types of databases in Node.js?\n\n**Answer:**\nNode.js can connect to various databases through different packages/drivers. Here are common approaches for popular databases:\n\n**SQL Databases:**\n- MySQL: Use `mysql2` or `mysql` packages\n- PostgreSQL: Use `pg` package\n- SQLite: Use `sqlite3` package\n- MS SQL Server: Use `mssql` package\n\n**NoSQL Databases:**\n- MongoDB: Use `mongoose` or `mongodb` packages\n- Redis: Use `redis` package\n- Cassandra: Use `cassandra-driver` package\n\n**Connection Pooling:**\nMost database drivers support connection pooling to efficiently reuse connections.\n\nBelow are examples of connections to MySQL and MongoDB:"
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "// MySQL Connection with Connection Pool\nconst mysql = require('mysql2');\n\n// Create connection pool\nconst pool = mysql.createPool({\n  host: 'localhost',\n  user: 'user',\n  password: 'password',\n  database: 'mydatabase',\n  waitForConnections: true,\n  connectionLimit: 10,\n  queueLimit: 0\n});\n\n// Using the pool to query\npool.query('SELECT * FROM users WHERE id = ?', [userId], (err, results) => {\n  if (err) {\n    console.error('Error executing query:', err);\n    return;\n  }\n  console.log('Query results:', results);\n});\n\n// Using promise wrapper\nconst promisePool = pool.promise();\nasync function getUser(id) {\n  try {\n    const [rows] = await promisePool.query('SELECT * FROM users WHERE id = ?', [id]);\n    return rows[0];\n  } catch (error) {\n    console.error('Error:', error);\n    throw error;\n  }\n}"
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "// MongoDB Connection with Mongoose\nconst mongoose = require('mongoose');\n\n// Connection string\nconst mongoURI = 'mongodb://localhost:27017/mydatabase';\n\n// Connect to MongoDB\nmongoose.connect(mongoURI, {\n  useNewUrlParser: true,\n  useUnifiedTopology: true,\n  // useCreateIndex: true, // For older mongoose versions\n  // useFindAndModify: false // For older mongoose versions\n}).then(() => {\n  console.log('MongoDB connected successfully');\n}).catch(err => {\n  console.error('MongoDB connection error:', err);\n});\n\n// Define a schema\nconst userSchema = new mongoose.Schema({\n  name: String,\n  email: { type: String, required: true, unique: true },\n  age: Number,\n  createdAt: { type: Date, default: Date.now }\n});\n\n// Create a model\nconst User = mongoose.model('User', userSchema);\n\n// Using the model to create and query data\nasync function createUser(userData) {\n  try {\n    const newUser = new User(userData);\n    return await newUser.save();\n  } catch (error) {\n    console.error('Error creating user:', error);\n    throw error;\n  }\n}\n\nasync function findUserByEmail(email) {\n  try {\n    return await User.findOne({ email });\n  } catch (error) {\n    console.error('Error finding user:', error);\n    throw error;\n  }\n}"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "## Question 22: How does Node.js handle concurrency despite being single-threaded?\n\n**Answer:**\nNode.js uses several approaches to handle concurrency despite its single-threaded nature:\n\n1. **Event Loop:** The core mechanism that allows Node.js to perform non-blocking I/O operations\n\n2. **Worker Threads:** Introduced in Node.js v10, they allow CPU-intensive tasks to run in parallel\n\n3. **Child Processes:** Using `child_process` module to spawn separate processes\n\n4. **Cluster Module:** For creating child processes that share server ports\n\nBelow is an example using Worker Threads to perform CPU-intensive calculations:"
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "// main.js\nconst { Worker } = require('worker_threads');\n\nfunction runWorker(workerData) {\n  return new Promise((resolve, reject) => {\n    // Create a new worker\n    const worker = new Worker('./worker.js', { workerData });\n    \n    // Listen for messages from the worker\n    worker.on('message', resolve);\n    \n    // Listen for errors\n    worker.on('error', reject);\n    \n    // Listen for worker exit\n    worker.on('exit', (code) => {\n      if (code !== 0) {\n        reject(new Error(`Worker stopped with exit code ${code}`));\n      }\n    });\n  });\n}\n\nasync function main() {\n  try {\n    // Create multiple workers to run tasks in parallel\n    const result1 = runWorker({ start: 1, end: 1000000 });\n    const result2 = runWorker({ start: 1000001, end: 2000000 });\n    const result3 = runWorker({ start: 2000001, end: 3000000 });\n    const result4 = runWorker({ start: 3000001, end: 4000000 });\n\n    // Wait for all workers to complete\n    const results = await Promise.all([result1, result2, result3, result4]);\n    console.log('Results:', results);\n  } catch (err) {\n    console.error(err);\n  }\n}\n\nmain();"
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "// worker.js\nconst { workerData, parentPort } = require('worker_threads');\n\n// CPU-intensive task (e.g., calculating prime numbers)\nfunction findPrimes(start, end) {\n  const primes = [];\n  for (let num = start; num <= end; num++) {\n    let isPrime = true;\n    for (let i = 2; i <= Math.sqrt(num); i++) {\n      if (num % i === 0) {\n        isPrime = false;\n        break;\n      }\n    }\n    if (isPrime && num > 1) {\n      primes.push(num);\n    }\n  }\n  return primes;\n}\n\n// Execute the task with the provided data\nconst primes = findPrimes(workerData.start, workerData.end);\n\n// Send the result back to the main thread\nparentPort.postMessage({ \n  primes: primes.length, \n  range: `${workerData.start}-${workerData.end}` \n});"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "## Question 23: How would you implement scheduled tasks (cron jobs) in Node.js?\n\n**Answer:**\nScheduled tasks or cron jobs in Node.js can be implemented using several packages:\n\n1. **node-cron:** Simple cron-like task scheduler\n2. **node-schedule:** Flexible job scheduler\n3. **agenda:** Lightweight job scheduling library with MongoDB persistence\n4. **bull:** Redis-based queue for handling distributed jobs\n\nThese libraries allow you to schedule tasks to run at specific times or intervals. Here's an example using node-cron:"
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "const cron = require('node-cron');\nconst fs = require('fs');\nconst nodemailer = require('nodemailer');\n\n// Schedule a task that runs every day at 00:00\ncron.schedule('0 0 * * *', async () => {\n  try {\n    console.log('Running daily backup task');\n    await performDatabaseBackup();\n    await sendBackupConfirmationEmail();\n    console.log('Daily backup completed successfully');\n  } catch (error) {\n    console.error('Error in daily backup task:', error);\n  }\n});\n\n// Schedule a task that runs every 5 minutes\ncron.schedule('*/5 * * * *', () => {\n  console.log('Checking for new data every 5 minutes');\n  // Implement data check logic\n});\n\n// Schedule a task that runs every Monday at 9:00\ncron.schedule('0 9 * * 1', () => {\n  console.log('Sending weekly report');\n  // Generate and send weekly report\n});\n\n// Helper function for database backup\nasync function performDatabaseBackup() {\n  // Example implementation\n  return new Promise((resolve, reject) => {\n    // Connect to database and create backup\n    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\n    const filename = `backup-${timestamp}.sql`;\n    \n    // This is just an example, real implementation would depend on your database\n    const backupProcess = require('child_process').spawn('mysqldump', [\n      '-u', 'username',\n      '-p', 'password',\n      'database_name'\n    ]);\n    \n    const writeStream = fs.createWriteStream(`./backups/${filename}`);\n    backupProcess.stdout.pipe(writeStream);\n    \n    writeStream.on('finish', resolve);\n    writeStream.on('error', reject);\n  });\n}\n\n// Helper function to send email confirmation\nasync function sendBackupConfirmationEmail() {\n  // Configure email transporter\n  const transporter = nodemailer.createTransport({\n    host: 'smtp.example.com',\n    port: 587,\n    secure: false,\n    auth: {\n      user: 'user@example.com',\n      pass: 'password'\n    }\n  });\n  \n  // Send email\n  await transporter.sendMail({\n    from: 'system@example.com',\n    to: 'admin@example.com',\n    subject: 'Database Backup Completed',\n    text: `Database backup completed successfully at ${new Date().toISOString()}`,\n    html: `<p>Database backup completed successfully at <b>${new Date().toISOString()}</b></p>`\n  });\n}"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "## Question 24: What are common data structures used in Node.js applications and how would you implement them?\n\n**Answer:**\nNode.js applications commonly use various data structures for efficient data handling:\n\n1. **Arrays and Objects:** Native JavaScript constructs\n2. **Maps and Sets:** ES6 collections for key-value pairs and unique values\n3. **Linked Lists, Stacks, Queues:** Can be implemented for specific use cases\n4. **Trees and Graphs:** Used for hierarchical data and relationships\n5. **Priority Queues:** Often implemented with heap structures\n\nHere are examples of implementing some of these data structures:"
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "// Implementation of a Queue data structure\nclass Queue {\n  constructor() {\n    this.items = {};\n    this.frontIndex = 0;\n    this.backIndex = 0;\n  }\n  \n  // Add an element to the queue\n  enqueue(item) {\n    this.items[this.backIndex] = item;\n    this.backIndex++;\n    return item;\n  }\n  \n  // Remove an element from the queue\n  dequeue() {\n    if (this.isEmpty()) {\n      return undefined;\n    }\n    \n    const item = this.items[this.frontIndex];\n    delete this.items[this.frontIndex];\n    this.frontIndex++;\n    return item;\n  }\n  \n  // Check if the queue is empty\n  isEmpty() {\n    return this.frontIndex === this.backIndex;\n  }\n  \n  // Return the front element without removing it\n  peek() {\n    if (this.isEmpty()) {\n      return undefined;\n    }\n    return this.items[this.frontIndex];\n  }\n  \n  // Get the size of the queue\n  size() {\n    return this.backIndex - this.frontIndex;\n  }\n  \n  // Clear the queue\n  clear() {\n    this.items = {};\n    this.frontIndex = 0;\n    this.backIndex = 0;\n  }\n}\n\n// Example usage\nconst requestQueue = new Queue();\nrequestQueue.enqueue({ id: 1, path: '/api/users' });\nrequestQueue.enqueue({ id: 2, path: '/api/products' });\nconsole.log('Queue size:', requestQueue.size()); // 2\nconsole.log('Next request:', requestQueue.peek()); // { id: 1, path: '/api/users' }\nconst nextRequest = requestQueue.dequeue();\nconsole.log('Processing request:', nextRequest); // { id: 1, path: '/api/users' }\nconsole.log('Queue size after dequeue:', requestQueue.size()); // 1"
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "// Implementation of a binary search tree\nclass Node {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\nclass BinarySearchTree {\n  constructor() {\n    this.root = null;\n  }\n  \n  // Insert a value into the tree\n  insert(value) {\n    const newNode = new Node(value);\n    \n    if (this.root === null) {\n      this.root = newNode;\n      return this;\n    }\n    \n    let current = this.root;\n    \n    while (true) {\n      // Ignore duplicates\n      if (value === current.value) return undefined;\n      \n      if (value < current.value) {\n        // Go left\n        if (current.left === null) {\n          current.left = newNode;\n          return this;\n        }\n        current = current.left;\n      } else {\n        // Go right\n        if (current.right === null) {\n          current.right = newNode;\n          return this;\n        }\n        current = current.right;\n      }\n    }\n  }\n  \n  // Find a value in the tree\n  find(value) {\n    if (this.root === null) return false;\n    \n    let current = this.root;\n    let found = false;\n    \n    while (current && !found) {\n      if (value < current.value) {\n        current = current.left;\n      } else if (value > current.value) {\n        current = current.right;\n      } else {\n        found = true;\n      }\n    }\n    \n    if (!found) return undefined;\n    return current;\n  }\n  \n  // Breadth-first search (level by level)\n  breadthFirstSearch() {\n    const data = [];\n    const queue = [];\n    let node = this.root;\n    \n    queue.push(node);\n    \n    while (queue.length) {\n      node = queue.shift();\n      data.push(node.value);\n      \n      if (node.left) queue.push(node.left);\n      if (node.right) queue.push(node.right);\n    }\n    \n    return data;\n  }\n}\n\n// Example usage\nconst bst = new BinarySearchTree();\nbst.insert(10);\nbst.insert(6);\nbst.insert(15);\nbst.insert(3);\nbst.insert(8);\nbst.insert(20);\n\nconsole.log('Find 10:', bst.find(10) ? 'Found' : 'Not found'); // Found\nconsole.log('Find 7:', bst.find(7) ? 'Found' : 'Not found');  // Not found\nconsole.log('BFS traversal:', bst.breadthFirstSearch()); // [10, 6, 15, 3, 8, 20]"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "## Question 25: How do you implement object-oriented programming patterns in Node.js?\n\n**Answer:**\nNode.js supports various approaches to implement object-oriented programming (OOP) patterns:\n\n1. **ES6 Classes:** Modern JavaScript class-based approach\n2. **Constructor Functions:** Traditional JavaScript way with prototypes\n3. **Factory Functions:** Creating objects without using `new`\n4. **Modules:** Encapsulation through the module system\n\nCommon OOP patterns implemented in Node.js include:\n- Inheritance (extending classes)\n- Encapsulation (private members using closures)\n- Polymorphism (method overriding)\n- Composition (has-a relationships)\n\nHere are examples of implementing OOP in Node.js:"
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "// ES6 Classes approach for OOP in Node.js\nclass Vehicle {\n  constructor(make, model, year) {\n    this.make = make;\n    this.model = model;\n    this.year = year;\n    this._mileage = 0; // Protected property (convention)\n  }\n  \n  // Getter method\n  get mileage() {\n    return this._mileage;\n  }\n  \n  // Setter method (with validation)\n  set mileage(value) {\n    if (value < 0) {\n      throw new Error('Mileage cannot be negative');\n    }\n    this._mileage = value;\n  }\n  \n  // Instance method\n  getInfo() {\n    return `${this.year} ${this.make} ${this.model}`;\n  }\n  \n  // Static method\n  static comparePrice(vehicleA, vehicleB) {\n    // Implementation would depend on a price property\n    return vehicleA.price - vehicleB.price;\n  }\n}\n\n// Inheritance\nclass Car extends Vehicle {\n  constructor(make, model, year, numDoors) {\n    super(make, model, year); // Call parent constructor\n    this.numDoors = numDoors;\n  }\n  \n  // Override parent method\n  getInfo() {\n    return `${super.getInfo()}, ${this.numDoors} doors`;\n  }\n  \n  // Additional method\n  honk() {\n    return 'Beep beep!';\n  }\n}\n\n// Example usage\nconst myCar = new Car('Toyota', 'Camry', 2022, 4);\nconsole.log(myCar.getInfo()); // '2022 Toyota Camry, 4 doors'\nconsole.log(myCar.honk()); // 'Beep beep!'\n\ntry {\n  myCar.mileage = 5000; // Using the setter\n  console.log(`Current mileage: ${myCar.mileage}`); // Using the getter\n  \n  myCar.mileage = -100; // Will throw an error\n} catch (error) {\n  console.error('Error:', error.message);\n}"
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "// Module pattern for encapsulation in Node.js\n// userService.js\nconst crypto = require('crypto');\n\n// Private variables and functions\nconst users = new Map();\nconst saltRounds = 10;\n\nfunction hashPassword(password) {\n  // Simple hash function for example purposes\n  return crypto.createHash('sha256').update(password).digest('hex');\n}\n\nfunction validateEmail(email) {\n  const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n  return emailRegex.test(email);\n}\n\n// Public API\nmodule.exports = {\n  // Create a new user\n  createUser(email, password, name) {\n    if (!validateEmail(email)) {\n      throw new Error('Invalid email format');\n    }\n    \n    if (users.has(email)) {\n      throw new Error('User with this email already exists');\n    }\n    \n    const hashedPassword = hashPassword(password);\n    const newUser = {\n      id: crypto.randomUUID(),\n      email,\n      password: hashedPassword,\n      name,\n      createdAt: new Date()\n    };\n    \n    users.set(email, newUser);\n    return { id: newUser.id, email: newUser.email, name: newUser.name };\n  },\n  \n  // Get user by email (returns a copy without password)\n  getUserByEmail(email) {\n    const user = users.get(email);\n    if (!user) return null;\n    \n    // Return copy without password\n    const { password, ...userWithoutPassword } = user;\n    return userWithoutPassword;\n  },\n  \n  // Authenticate user\n  authenticateUser(email, password) {\n    const user = users.get(email);\n    if (!user) return false;\n    \n    const hashedPassword = hashPassword(password);\n    return user.password === hashedPassword;\n  },\n  \n  // Update user\n  updateUser(email, updates) {\n    if (!users.has(email)) {\n      throw new Error('User not found');\n    }\n    \n    const user = users.get(email);\n    const updatedUser = { ...user, ...updates, updatedAt: new Date() };\n    \n    // Don't allow email updates this way\n    updatedUser.email = user.email;\n    \n    users.set(email, updatedUser);\n    \n    // Return copy without password\n    const { password, ...userWithoutPassword } = updatedUser;\n    return userWithoutPassword;\n  },\n  \n  // Delete user\n  deleteUser(email) {\n    return users.delete(email);\n  }\n};\n\n// Usage in another file\n// const userService = require('./userService');\n// const user = userService.createUser('user@example.com', 'securePassword', 'John Doe');"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "## Question 26: How would you design and implement a data access layer in a Node.js application?\n\n**Answer:**\nA data access layer (DAL) in Node.js applications separates business logic from data storage details. Design patterns for DAL include:\n\n1. **Repository Pattern:** Abstracts the data layer and centralizes data access logic\n2. **DAO (Data Access Object):** Similar to repository but typically more focused on CRUD operations\n3. **ORM/ODM:** Using tools like Sequelize (SQL) or Mongoose (MongoDB) for object mapping\n\nHere's an implementation of a repository pattern with MongoDB:"
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "// Repository Pattern for MongoDB in Node.js\n// product-repository.js\nconst { ObjectId } = require('mongodb');\n\nclass ProductRepository {\n  constructor(db) {\n    this.collection = db.collection('products');\n  }\n  \n  // Find all products with optional filtering\n  async findAll(filters = {}, options = {}) {\n    const { skip = 0, limit = 50, sort = { createdAt: -1 } } = options;\n    \n    return await this.collection\n      .find(filters)\n      .sort(sort)\n      .skip(skip)\n      .limit(limit)\n      .toArray();\n  }\n  \n  // Find product by ID\n  async findById(id) {\n    if (!ObjectId.isValid(id)) return null;\n    return await this.collection.findOne({ _id: new ObjectId(id) });\n  }\n  \n  // Find products by category\n  async findByCategory(category) {\n    return await this.collection.find({ category }).toArray();\n  }\n  \n  // Create a new product\n  async create(productData) {\n    const now = new Date();\n    const newProduct = {\n      ...productData,\n      createdAt: now,\n      updatedAt: now\n    };\n    \n    const result = await this.collection.insertOne(newProduct);\n    return { ...newProduct, _id: result.insertedId };\n  }\n  \n  // Update a product\n  async update(id, updateData) {\n    if (!ObjectId.isValid(id)) throw new Error('Invalid product ID');\n    \n    const updates = {\n      ...updateData,\n      updatedAt: new Date()\n    };\n    \n    const result = await this.collection.findOneAndUpdate(\n      { _id: new ObjectId(id) },\n      { $set: updates },\n      { returnDocument: 'after' }\n    );\n    \n    return result.value;\n  }\n  \n  // Delete a product\n  async delete(id) {\n    if (!ObjectId.isValid(id)) throw new Error('Invalid product ID');\n    \n    const result = await this.collection.deleteOne({ _id: new ObjectId(id) });\n    return result.deletedCount > 0;\n  }\n  \n  // Search products\n  async search(text) {\n    // Assuming text index is created on the collection\n    return await this.collection.find({\n      $text: { $search: text }\n    }).toArray();\n  }\n  \n  // Update stock quantity\n  async updateStock(id, quantityChange) {\n    if (!ObjectId.isValid(id)) throw new Error('Invalid product ID');\n    \n    const result = await this.collection.findOneAndUpdate(\n      { _id: new ObjectId(id) },\n      { \n        $inc: { quantity: quantityChange },\n        $set: { updatedAt: new Date() }\n      },\n      { returnDocument: 'after' }\n    );\n    \n    return result.value;\n  }\n}"
            ],
            "outputs": []
        },
        {
            "language": "javascript",
            "source": [
                "// Example usage of the ProductRepository\n// app.js\nconst { MongoClient } = require('mongodb');\nconst ProductRepository = require('./product-repository');\n\nasync function main() {\n  // Connect to MongoDB\n  const client = new MongoClient('mongodb://localhost:27017');\n  await client.connect();\n  \n  const db = client.db('ecommerce');\n  const productRepo = new ProductRepository(db);\n  \n  try {\n    // Create a new product\n    const newProduct = await productRepo.create({\n      name: 'Smartphone XYZ',\n      price: 599.99,\n      category: 'electronics',\n      description: 'Latest smartphone with amazing features',\n      quantity: 100,\n      tags: ['smartphone', 'android', '5G']\n    });\n    console.log('Created product:', newProduct);\n    \n    // Find products by category\n    const electronicsProducts = await productRepo.findByCategory('electronics');\n    console.log(`Found ${electronicsProducts.length} electronics products`);\n    \n    // Update stock\n    const updatedProduct = await productRepo.updateStock(newProduct._id, -5);\n    console.log('Updated stock:', updatedProduct.quantity); // Should be 95\n    \n    // Search for products\n    const searchResults = await productRepo.search('smartphone');\n    console.log(`Search results: ${searchResults.length} products found`);\n    \n  } catch (error) {\n    console.error('Error:', error);\n  } finally {\n    await client.close();\n  }\n}\n\nmain().catch(console.error);"
            ],
            "outputs": []
        }
    ]
}